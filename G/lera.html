<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Валерия: Crockid Mall</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB; /* Небо */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Экран загрузки */
        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 99%, #fecfef 100%);
            display: flex;
            flex-direction: column;
            justify-content: flex-end; /* Кнопки внизу */
            align-items: center;
            z-index: 200;
            color: #fff;
            transition: opacity 0.5s;
            padding-bottom: 100px; /* Отступ снизу */
            box-sizing: border-box;
        }

        /* Канвас для интро (героиня и сатурн) */
        #intro-canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* Позади текста */
            pointer-events: none;
        }

        #loading-screen h1 {
            font-size: 3.5rem;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 3px;
            color: #fff;
            text-shadow: 4px 4px 0px #ff00de;
            animation: bounce 2s infinite;
            text-align: center;
            position: absolute;
            top: 15%;
        }

        #loading-screen p {
            font-size: 1.5rem;
            color: #fff;
            margin-bottom: 40px;
            font-weight: bold;
            text-shadow: 2px 2px 0px rgba(0,0,0,0.2);
            position: absolute;
            top: 25%;
        }

        #play-btn {
            background: #fff;
            color: #ff00de;
            border: 4px solid #fff;
            padding: 15px 60px;
            font-size: 24px;
            border-radius: 15px;
            cursor: pointer;
            font-weight: 900;
            box-shadow: 0 8px 0px rgba(0,0,0,0.1);
            transition: transform 0.1s, box-shadow 0.1s;
            z-index: 10;
        }

        #play-btn:active {
            transform: translateY(4px);
            box-shadow: 0 4px 0px rgba(0,0,0,0.1);
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* UI Игры */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
        }

        .hud-panel {
            background: #fff;
            padding: 15px 20px;
            border-radius: 15px;
            border: 4px solid #333;
            display: flex;
            flex-direction: column;
            gap: 5px;
            box-shadow: 6px 6px 0px rgba(0,0,0,0.2);
            align-self: flex-start;
        }

        #score-board {
            font-size: 20px;
            font-weight: 900;
            color: #ff00de;
            text-transform: uppercase;
        }

        #status {
            font-size: 16px;
            font-weight: 700;
            color: #00cc66;
        }

        /* Джойстик */
        #joystick-ui {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 120px;
            height: 120px;
            border: 4px solid rgba(255, 255, 255, 0.6);
            background: rgba(0,0,0,0.1);
            border-radius: 50%;
            pointer-events: none;
            display: none;
        }
        
        #joystick-stick {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: #ff66b2;
            border: 2px solid #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 4px 0 rgba(0,0,0,0.2);
        }

        /* Game Over */
        #game-over {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #fff;
            color: #333;
            padding: 40px;
            text-align: center;
            border: 6px solid #ff00de;
            border-radius: 20px;
            pointer-events: auto;
            z-index: 100;
            box-shadow: 10px 10px 0px rgba(0,0,0,0.2);
            min-width: 300px;
        }

        #go-title {
            font-size: 32px;
            margin: 0 0 15px 0;
            font-weight: 900;
            text-transform: uppercase;
        }
        
        #restart-btn {
            background: #00cc66;
            color: #fff;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
            font-weight: bold;
            box-shadow: 0 5px 0 #00994d;
        }
        
        #restart-btn:active {
            transform: translateY(3px);
            box-shadow: 0 2px 0 #00994d;
        }

        /* Зона управления */
        #touch-zone {
            position: absolute;
            top: 0;
            left: 0;
            width: 50%;
            height: 100%;
            z-index: 5;
            pointer-events: auto;
            cursor: crosshair;
        }
    </style>
</head>
<body>

    <!-- Стартовый экран -->
    <div id="loading-screen">
        <div id="intro-canvas-container"></div>
        <h1>ВАЛЕРИЯ</h1>
        <p>Собери 7 шапочек Crockid</p>
        <button id="play-btn">В МОЛЛ!</button>
    </div>

    <!-- 3D Контейнер -->
    <div id="game-container"></div>
    
    <!-- Зона сенсора/мыши -->
    <div id="touch-zone"></div>

    <!-- Интерфейс -->
    <div id="ui-layer">
        <div class="hud-panel">
            <div id="score-board">Шапочки Crockid: 0 / 7</div>
            <div id="status">Здоровье: 100%</div>
        </div>
        
        <!-- Визуальный джойстик -->
        <div id="joystick-ui">
            <div id="joystick-stick"></div>
        </div>
    </div>

    <!-- Конец игры -->
    <div id="game-over">
        <h1 id="go-title">ПОЙМАНА!</h1>
        <p id="go-reason"></p>
        <button id="restart-btn" onclick="location.reload()">ЕЩЕ РАЗ</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // --- НАСТРОЙКИ ---
        const PLAYER_SPEED = 0.25; 
        const GRAVITY = 0.8;
        const ENEMY_SPEED = 0.14; 
        const CELL_SIZE = 10; 
        const TOTAL_COLLECTIBLES = 7; 
        
        // Карта уровня (Симметричный Молл)
        const LEVEL_MAP = [
            "11111111111111111",
            "10000000100000001",
            "10111110101111101",
            "101...10101...101",
            "101.1.10101.1.101",
            "10001000000010001",
            "11101011.11010111",
            "1000001...1000001",
            "10111000P00011101",
            "1000001...1000001",
            "11101011.11010111",
            "10001000000010001",
            "101.1.10101.1.101",
            "101...10101...101",
            "10111110101111101",
            "10000000100000001",
            "11111111111111111"
        ];

        let scene, camera, renderer;
        let player, playerGroup, playerLight;
        let mazeWallsBB = []; 
        let floorBB = [];
        let enemies = [], collectibles = [];
        let particles = [];
        let water;
        let validSpawnPoints = [];
        
        let isGameActive = false;
        let isGameOver = false;
        let health = 100;
        let score = 0;
        let lastDamageTime = 0; 
        
        let moveVector = { x: 0, y: 0 };
        let joystickCenter = { x: 0, y: 0 }; 
        let isDragging = false; 

        // DOM элементы
        const uiLayer = document.getElementById('ui-layer');
        const loadingScreen = document.getElementById('loading-screen');
        const playBtn = document.getElementById('play-btn');
        const joystickUi = document.getElementById('joystick-ui');
        const joystickStick = document.getElementById('joystick-stick');
        const scoreEl = document.getElementById('score-board');
        const statusEl = document.getElementById('status');
        const gameOverEl = document.getElementById('game-over');
        const goTitleEl = document.getElementById('go-title');
        const goReasonEl = document.getElementById('go-reason');

        // Глобальная функция создания боксов
        function createBox(w, h, d, color, x, y, z) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mat = new THREE.MeshLambertMaterial({ color: color, flatShading: true }); 
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            return mesh;
        }

        // Функция создания героини (для игры и интро)
        function createHeroineModel() {
            const group = new THREE.Group();
            const limbs = {};

            // Тело
            const body = createBox(0.6, 0.8, 0.4, 0xff3399, 0, 0.9, 0); // Розовое платье
            group.add(body);
            
            // Голова
            const headGroup = new THREE.Group();
            headGroup.position.set(0, 1.6, 0);
            
            const face = createBox(0.6, 0.6, 0.6, 0xffccaa, 0, 0, 0); // Кожа
            headGroup.add(face);

            // Волосы (Каре)
            const hairColor = 0xffeebb; // Светло-желтый блонд
            const hairTop = createBox(0.7, 0.2, 0.7, hairColor, 0, 0.35, 0);
            const hairBack = createBox(0.7, 0.6, 0.2, hairColor, 0, 0, 0.25);
            const hairL = createBox(0.15, 0.6, 0.5, hairColor, -0.28, 0, -0.05);
            const hairR = createBox(0.15, 0.6, 0.5, hairColor, 0.28, 0, -0.05);
            headGroup.add(hairTop, hairBack, hairL, hairR);

            // Глаза (Зеленые)
            const eyeL = createBox(0.1, 0.1, 0.05, 0x00aa00, -0.15, 0, -0.31);
            const eyeR = createBox(0.1, 0.1, 0.05, 0x00aa00, 0.15, 0, -0.31);
            headGroup.add(eyeL, eyeR);

            group.add(headGroup);
            
            // Руки
            const armL = createBox(0.2, 0.6, 0.2, 0xffccaa, -0.45, 1.0, 0);
            // Смещаем пивот для вращения (плечо)
            armL.geometry.translate(0, -0.2, 0); 
            group.add(armL);
            limbs.armL = armL;

            const armR = createBox(0.2, 0.6, 0.2, 0xffccaa, 0.45, 1.0, 0);
            armR.geometry.translate(0, -0.2, 0);
            group.add(armR);
            limbs.armR = armR;
            
            // Ноги
            const legL = createBox(0.22, 0.6, 0.22, 0x333333, -0.15, 0.3, 0);
            legL.geometry.translate(0, -0.3, 0); // Пивот в бедре
            group.add(legL);
            limbs.legL = legL;

            const legR = createBox(0.22, 0.6, 0.22, 0x333333, 0.15, 0.3, 0);
            legR.geometry.translate(0, -0.3, 0);
            group.add(legR);
            limbs.legR = legR;

            group.userData.limbs = limbs;
            return group;
        }

        // --- ЛОГИКА ИНТРО ---
        let introScene, introCamera, introRenderer, introId;
        let introHeroine, introSaturn;

        function initIntro() {
            const container = document.getElementById('intro-canvas-container');
            introScene = new THREE.Scene();
            
            introCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            introCamera.position.set(0, 0, 15);

            introRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            introRenderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(introRenderer.domElement);

            const ambient = new THREE.AmbientLight(0xffffff, 0.8);
            introScene.add(ambient);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 5, 10);
            introScene.add(dirLight);

            // 1. Героиня
            introHeroine = createHeroineModel();
            introHeroine.position.set(-2, -1, 0);
            // Поворачиваем чтобы смотрела на зрителя немного боком
            introHeroine.rotation.y = 0.5; 
            introScene.add(introHeroine);

            // 2. Сатурн
            introSaturn = new THREE.Group();
            const planetGeo = new THREE.IcosahedronGeometry(1.8, 0);
            const planetMat = new THREE.MeshLambertMaterial({ color: 0xffcc44, flatShading: true });
            const planet = new THREE.Mesh(planetGeo, planetMat);
            
            const ringGeo = new THREE.TorusGeometry(3, 0.6, 2, 12);
            const ringMat = new THREE.MeshLambertMaterial({ color: 0xffaa88, flatShading: true });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = Math.PI / 2;
            ring.scale.z = 0.1;

            introSaturn.add(planet, ring);
            introSaturn.position.set(3, 2, -2);
            introSaturn.rotation.x = 0.4;
            introSaturn.rotation.z = 0.2;
            introScene.add(introSaturn);

            animateIntro();
            window.addEventListener('resize', onIntroResize);
        }

        function onIntroResize() {
            if(introCamera && introRenderer) {
                introCamera.aspect = window.innerWidth / window.innerHeight;
                introCamera.updateProjectionMatrix();
                introRenderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        function animateIntro() {
            introId = requestAnimationFrame(animateIntro);
            
            if (introHeroine) {
                // Анимация в меню: просто машет рукой
                introHeroine.rotation.y += 0.01;
                const time = Date.now() * 0.005;
                introHeroine.userData.limbs.armR.rotation.x = Math.sin(time) * 0.5;
                introHeroine.userData.limbs.armL.rotation.x = -Math.sin(time) * 0.5;
            }
            if (introSaturn) {
                introSaturn.rotation.y -= 0.005;
                introSaturn.rotation.z = 0.2 + Math.sin(Date.now() * 0.001) * 0.1;
            }

            introRenderer.render(introScene, introCamera);
        }

        function stopIntro() {
            cancelAnimationFrame(introId);
            window.removeEventListener('resize', onIntroResize);
            const container = document.getElementById('intro-canvas-container');
            if (container && introRenderer) {
                container.removeChild(introRenderer.domElement);
            }
            introRenderer = null;
        }

        // --- ИГРА ---
        playBtn.addEventListener('click', startGame);
        initIntro();

        function startGame() {
            stopIntro();
            loadingScreen.style.opacity = '0';
            setTimeout(() => {
                loadingScreen.style.display = 'none';
                uiLayer.style.display = 'flex';
                joystickUi.style.display = 'block';
                isGameActive = true;
                const rect = joystickUi.getBoundingClientRect();
                if (rect.width > 0) {
                    joystickCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
                }
            }, 500);
            initThreeJS();
        }

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 60);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 150);
            camera.position.set(0, 30, 20); 

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            document.getElementById('game-container').appendChild(renderer.domElement);

            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
            dirLight.position.set(50, 80, 40);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.left = -50;
            dirLight.shadow.camera.right = 50;
            dirLight.shadow.camera.top = 50;
            dirLight.shadow.camera.bottom = -50;
            scene.add(dirLight);

            createLevel();
            setupInputs();
            animate();

            window.addEventListener('resize', () => {
                if (!camera || !renderer) return;
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                const rect = joystickUi.getBoundingClientRect();
                if (rect.width > 0 && joystickUi.style.display !== 'none') {
                    joystickCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
                }
            });
        }

        function createLevel() {
            // ИГРОК
            playerGroup = createHeroineModel();
            player = playerGroup;
            player.userData.velocityY = 0; 
            player.userData.isGrounded = false;
            // Сбрасываем позицию (будет установлена в цикле P)
            player.position.set(0, 0, 0);
            scene.add(player);

            // УРОВЕНЬ
            const rows = LEVEL_MAP.length;
            const cols = LEVEL_MAP[0].length;
            const offsetX = (cols * CELL_SIZE) / 2;
            const offsetZ = (rows * CELL_SIZE) / 2;

            const floorGeo = new THREE.BoxGeometry(CELL_SIZE, 1, CELL_SIZE);
            const floorMat1 = new THREE.MeshLambertMaterial({ color: 0xF5DEB3 });
            const floorMat2 = new THREE.MeshLambertMaterial({ color: 0xEEE8AA });

            for (let z = 0; z < rows; z++) {
                for (let x = 0; x < cols; x++) {
                    const char = LEVEL_MAP[z][x];
                    const posX = x * CELL_SIZE - offsetX;
                    const posZ = z * CELL_SIZE - offsetZ;

                    if (char === '1') {
                        const shelf = createBox(CELL_SIZE, 6, CELL_SIZE, 0xffffff, posX, 2.5, posZ);
                        scene.add(shelf);
                        for(let k=0; k<5; k++) {
                            const pColor = Math.random() * 0xffffff;
                            scene.add(createBox(2, 1.5, 1, pColor, posX + (Math.random()-0.5)*6, 1 + Math.random()*4, posZ + (CELL_SIZE/2 + 0.1) * (Math.random()>0.5?1:-1)));
                        }
                        mazeWallsBB.push(new THREE.Box3().setFromObject(shelf));
                    } else if (char === '0' || char === 'P') {
                        const fMat = ((x+z)%2 === 0) ? floorMat1 : floorMat2;
                        const floor = new THREE.Mesh(floorGeo, fMat);
                        floor.position.set(posX, -0.5, posZ);
                        floor.receiveShadow = true;
                        scene.add(floor);
                        floorBB.push(new THREE.Box3().setFromObject(floor));
                        
                        if (char === '0') {
                            validSpawnPoints.push(new THREE.Vector3(posX, 0, posZ));
                            if (Math.random() > 0.85) createDecor(posX, posZ);
                        }
                        if (char === 'P') {
                            player.position.set(posX, 0, posZ);
                        }
                    }
                }
            }

            validSpawnPoints.sort(() => Math.random() - 0.5);

            const wGeo = new THREE.PlaneGeometry(500, 500);
            const wMat = new THREE.MeshLambertMaterial({ color: 0x44aaff, transparent: true, opacity: 0.8 });
            water = new THREE.Mesh(wGeo, wMat);
            water.rotation.x = -Math.PI / 2;
            water.position.y = -5;
            scene.add(water);

            spawnEntities();
        }

        function createDecor(x, z) {
            if (Math.random() > 0.5) {
                const bin = createBox(1.5, 2.5, 1.5, 0x555555, x, 0.75, z); 
                const lid = createBox(1.7, 0.2, 1.7, 0x333333, x, 2.1, z); 
                scene.add(bin, lid);
                mazeWallsBB.push(new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(x, 1.25, z), new THREE.Vector3(1.5, 2.5, 1.5)));
            } else {
                const bench = createBox(4, 1.5, 2, 0xcc9966, x, 0.25, z);
                scene.add(bench);
                mazeWallsBB.push(new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(x, 0.75, z), new THREE.Vector3(4, 1.5, 2)));
            }
        }

        function spawnEntities() {
            let spawnIndex = 0;
            // Шапочки
            for (let i = 0; i < TOTAL_COLLECTIBLES; i++) {
                if (spawnIndex >= validSpawnPoints.length) spawnIndex = 0;
                const pos = validSpawnPoints[spawnIndex++];
                const hatGroup = new THREE.Group();
                const base = createBox(1, 0.8, 1, (i%2==0 ? 0xff00de : 0x00ffff), 0, 0, 0);
                const pom = createBox(0.4, 0.4, 0.4, 0xffffff, 0, 0.6, 0);
                hatGroup.add(base, pom);
                hatGroup.position.set(pos.x, 1, pos.z);
                scene.add(hatGroup);
                collectibles.push({ mesh: hatGroup, active: true, basePathY: 1 });
            }
            // Враги
            const bananaGeo = new THREE.TorusGeometry(0.7, 0.3, 8, 12, Math.PI/1.2); 
            const bananaMat = new THREE.MeshLambertMaterial({ color: 0xffdd00 }); 
            for(let i=0; i<6; i++) {
                if (spawnIndex >= validSpawnPoints.length) break;
                const pos = validSpawnPoints[spawnIndex++];
                const b = new THREE.Mesh(bananaGeo, bananaMat);
                b.position.set(pos.x, 2, pos.z);
                b.rotation.x = -Math.PI/2;
                b.castShadow = true;
                enemies.push({ mesh: b, type: 'banana', speed: ENEMY_SPEED, jumpOffset: Math.random() * 10 });
                scene.add(b);
            }
            const bodyGeo = new THREE.CylinderGeometry(0.2, 0.2, 1.2, 8);
            const mothMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); 
            const wingGeo = new THREE.PlaneGeometry(1.8, 1);
            const wingMat = new THREE.MeshBasicMaterial({ color: 0xddccaa, side: THREE.DoubleSide });
            for(let i=0; i<5; i++) {
                if (spawnIndex >= validSpawnPoints.length) break;
                const pos = validSpawnPoints[spawnIndex++];
                const grp = new THREE.Group();
                const body = new THREE.Mesh(bodyGeo, mothMat);
                body.rotation.x = Math.PI/2;
                body.castShadow = true;
                grp.add(body);
                const lw = new THREE.Mesh(wingGeo, wingMat);
                lw.position.x = -0.9;
                const rw = new THREE.Mesh(wingGeo, wingMat);
                rw.position.x = 0.9;
                grp.add(lw, rw);
                grp.position.set(pos.x, 8, pos.z);
                enemies.push({ mesh: grp, type: 'moth', speed: ENEMY_SPEED * 1.1, wings: [lw, rw] });
                scene.add(grp);
            }
        }

        // --- ФИЗИКА ---
        const playerBox = new THREE.Box3();
        const playerSize = new THREE.Vector3(0.8, 1.5, 0.8); 

        function checkWallCollision(newPos) {
            playerBox.setFromCenterAndSize(newPos, playerSize);
            for (let wall of mazeWallsBB) {
                if (playerBox.intersectsBox(wall)) return true;
            }
            return false;
        }

        function updatePhysics() {
            player.userData.velocityY -= 0.04; 
            player.position.y += player.userData.velocityY;

            let onGround = false;
            const feetPos = new THREE.Vector3(player.position.x, player.position.y + 0.5, player.position.z);
            const feetBox = new THREE.Box3().setFromCenterAndSize(feetPos, new THREE.Vector3(0.6, 1.0, 0.6));

            for (let floor of floorBB) {
                if (feetBox.intersectsBox(floor)) {
                    if (player.userData.velocityY <= 0 && player.position.y >= -0.5) {
                        player.position.y = 0; 
                        player.userData.velocityY = 0;
                        onGround = true;
                        // Тряску убрали, здесь просто логика приземления
                    }
                }
            }
            if (player.position.y < -5) endGame("УПАЛА С ЭТАЖА...", false);
        }

        function movePlayer() {
            const isMoving = (moveVector.x !== 0 || moveVector.y !== 0);
            
            if (isMoving) {
                let nextX = player.position.x + moveVector.x * PLAYER_SPEED;
                if (!checkWallCollision(new THREE.Vector3(nextX, player.position.y + 1, player.position.z))) {
                    player.position.x = nextX;
                }
                let nextZ = player.position.z + moveVector.y * PLAYER_SPEED;
                if (!checkWallCollision(new THREE.Vector3(player.position.x, player.position.y + 1, nextZ))) {
                    player.position.z = nextZ;
                }
                // Поворот: теперь 0 - это "вперед" (от камеры), PI - "назад" (к камере)
                // Модель построена так, что лицо смотрит в -Z. 
                // atan2(-x, -y) при нажатии ВВЕРХ (y=-1) дает atan2(0, 1) = 0.
                // То есть при нажатии ВВЕРХ игрок не вращается (смотрит в -Z). Это верно.
                player.rotation.y = Math.atan2(-moveVector.x, -moveVector.y);

                // Анимация ходьбы
                const time = Date.now() * 0.015;
                const limbs = player.userData.limbs;
                if (limbs) {
                    limbs.armL.rotation.x = Math.sin(time) * 0.6;
                    limbs.armR.rotation.x = -Math.sin(time) * 0.6;
                    limbs.legL.rotation.x = -Math.sin(time) * 0.6;
                    limbs.legR.rotation.x = Math.sin(time) * 0.6;
                }
            } else {
                // Сброс анимации если стоим
                const limbs = player.userData.limbs;
                if (limbs) {
                    limbs.armL.rotation.x = 0;
                    limbs.armR.rotation.x = 0;
                    limbs.legL.rotation.x = 0;
                    limbs.legR.rotation.x = 0;
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if (!isGameActive || isGameOver) return;

            updatePhysics();
            movePlayer();

            // Камера без тряски
            const targetCam = new THREE.Vector3(player.position.x + 12, player.position.y + 22, player.position.z + 12);
            camera.position.lerp(targetCam, 0.1); 
            camera.lookAt(player.position);

            updateGameObjects();
            renderer.render(scene, camera);
        }

        function updateGameObjects() {
            const time = Date.now() * 0.001;
            enemies.forEach(e => {
                const dist = player.position.distanceTo(e.mesh.position);
                if (e.type === 'banana') {
                    e.mesh.position.y = 2 + Math.abs(Math.sin(time * 5 + e.jumpOffset)) * 2;
                    e.mesh.rotation.y += 0.1;
                    if(dist < 18) {
                        const dir = new THREE.Vector3().subVectors(player.position, e.mesh.position).normalize();
                        e.mesh.position.add(dir.multiplyScalar(e.speed));
                    }
                } else if (e.type === 'moth') {
                    e.wings[0].rotation.z = Math.sin(time * 20);
                    e.wings[1].rotation.z = -Math.sin(time * 20);
                    if(dist < 25) {
                        const dir = new THREE.Vector3().subVectors(player.position, e.mesh.position).normalize();
                        e.mesh.position.add(dir.multiplyScalar(e.speed));
                        e.mesh.lookAt(player.position);
                    }
                }
                if (dist < 2.2) {
                    const now = Date.now();
                    if (now - lastDamageTime > 1000) { 
                        takeDamage(10); 
                        lastDamageTime = now;
                    }
                }
            });

            if (Date.now() - lastDamageTime < 1000) {
                player.visible = Math.floor(Date.now() / 100) % 2 === 0;
            } else {
                player.visible = true;
            }

            collectibles.forEach(c => {
                if(!c.active) return;
                c.mesh.rotation.y += 0.05;
                c.mesh.position.y = c.basePathY + Math.sin(time * 3) * 0.3;
                if (player.position.distanceTo(c.mesh.position) < 2.5) {
                    c.active = false;
                    scene.remove(c.mesh);
                    score++;
                    health = 100;
                    updateHealthUI();
                    scoreEl.innerText = `Шапочки Crockid: ${score} / ${TOTAL_COLLECTIBLES}`;
                    spawnParticles(c.mesh.position, 0xff00de);
                    if (score >= TOTAL_COLLECTIBLES) endGame("С ДНЕМ РОЖДЕНИЯ!", true);
                }
            });

            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.position.add(p.userData.vel);
                p.rotation.x += 0.1;
                p.scale.multiplyScalar(0.9);
                if(p.scale.x < 0.05) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }
        }

        function updateHealthUI() {
            statusEl.innerText = `Здоровье: ${Math.max(0, health)}%`;
            if (health === 100) {
                statusEl.style.color = '#00ff00';
                statusEl.style.textShadow = '0 0 10px #00ff00';
                setTimeout(() => {
                    statusEl.style.color = '#00cc66';
                    statusEl.style.textShadow = 'none';
                }, 500);
            }
        }

        function takeDamage(amount) {
            health -= amount;
            statusEl.innerText = `Здоровье: ${Math.max(0, health)}%`;
            statusEl.style.color = '#ff0000';
            document.body.style.backgroundColor = "#ffcccc";
            setTimeout(() => {
                document.body.style.backgroundColor = "#87CEEB";
                statusEl.style.color = '#00cc66';
            }, 100);
            if (health <= 0) endGame("СЪЕДЕНА КОШМАРАМИ!", false);
        }

        function spawnParticles(pos, color) {
            const geo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            const mat = new THREE.MeshBasicMaterial({ color: color });
            for(let i=0; i<8; i++) {
                const p = new THREE.Mesh(geo, mat);
                p.position.copy(pos);
                p.userData.vel = new THREE.Vector3((Math.random()-0.5), Math.random(), (Math.random()-0.5)).multiplyScalar(0.5);
                scene.add(p);
                particles.push(p);
            }
        }

        function endGame(reason, win) {
            isGameOver = true;
            gameOverEl.style.display = 'block';
            if (win) {
                goTitleEl.innerText = "С ДНЕМ РОЖДЕНИЯ!";
                goTitleEl.style.color = "#ff00de";
                goReasonEl.innerText = "Ты собрала все шапочки Crockid, Валерия!";
            } else {
                goTitleEl.innerText = "ПОЙМАНА";
                goTitleEl.style.color = "#ff3333";
                goReasonEl.innerText = reason;
            }
        }

        // --- ВВОД ---
        function setupInputs() {
            const tZone = document.getElementById('touch-zone');
            
            const handleInput = (x, y) => {
                const maxDist = 40;
                const dx = x - joystickCenter.x;
                const dy = y - joystickCenter.y;
                const dist = Math.min(Math.sqrt(dx*dx + dy*dy), maxDist);
                const angle = Math.atan2(dy, dx);
                const moveX = Math.cos(angle) * dist;
                const moveY = Math.sin(angle) * dist;

                joystickStick.style.transform = `translate(calc(-50% + ${moveX}px), calc(-50% + ${moveY}px))`;
                moveVector.x = moveX / maxDist;
                moveVector.y = moveY / maxDist;
            };

            const resetInput = () => {
                moveVector = { x: 0, y: 0 };
                joystickStick.style.transform = `translate(-50%, -50%)`;
                isDragging = false;
            };

            tZone.addEventListener('touchstart', (e) => { e.preventDefault(); handleInput(e.touches[0].clientX, e.touches[0].clientY); }, {passive: false});
            tZone.addEventListener('touchmove', (e) => { e.preventDefault(); handleInput(e.touches[0].clientX, e.touches[0].clientY); }, {passive: false});
            tZone.addEventListener('touchend', resetInput);

            tZone.addEventListener('mousedown', (e) => {
                isDragging = true;
                handleInput(e.clientX, e.clientY);
            });
            window.addEventListener('mousemove', (e) => {
                if (isDragging) handleInput(e.clientX, e.clientY);
            });
            window.addEventListener('mouseup', resetInput);

            const keys = {};
            window.addEventListener('keydown', e => keys[e.code] = true);
            window.addEventListener('keyup', e => keys[e.code] = false);
            
            setInterval(() => {
                if (isDragging) return;
                
                let dx = 0, dy = 0;
                if(keys['KeyW'] || keys['ArrowUp']) dy = -1;
                if(keys['KeyS'] || keys['ArrowDown']) dy = 1;
                if(keys['KeyA'] || keys['ArrowLeft']) dx = -1;
                if(keys['KeyD'] || keys['ArrowRight']) dx = 1;
                
                if(dx!==0 || dy!==0) {
                    moveVector = {x: dx, y: dy};
                    joystickStick.style.transform = `translate(calc(-50% + ${dx*20}px), calc(-50% + ${dy*20}px))`;
                }
            }, 16);
        }
    </script>
</body>
</html>
