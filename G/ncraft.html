<!DOCTYPE html>
<html lang="ru">
<head>
Â  Â  <meta charset="UTF-8">
Â  Â  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
Â  Â  <title>nblock v8.0 (Auto-Config)</title>
Â  Â  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
Â  Â  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
Â  Â  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
Â  Â  <style>
Â  Â  Â  Â  body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #87CEEB; color: white; touch-action: none; user-select: none; -webkit-user-select: none; }
Â  Â  Â  Â Â 
Â  Â  Â  Â  #blocker { position: absolute; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 20; cursor: pointer; }
Â  Â  Â  Â  #instructions { font-size: 36px; text-align: center; color: #fff; text-shadow: 0 2px 4px rgba(0,0,0,0.5); pointer-events: none; }
Â  Â  Â  Â  #instructions span { font-size: 16px; color: #ccc; display: block; margin-top: 10px; }
Â  Â  Â  Â Â 
Â  Â  Â  Â  #menu { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 30; }
Â  Â  Â  Â  .panel { background: #333; padding: 30px; border-radius: 10px; border: 2px solid #555; text-align: center; max-width: 400px; box-shadow: 0 10px 25px rgba(0,0,0,0.5); }
Â  Â  Â  Â  h1 { margin-top: 0; color: #4CAF50; text-transform: uppercase; letter-spacing: 2px; }
Â  Â  Â  Â  input { padding: 10px; width: 70%; border-radius: 5px; border: 1px solid #666; background: #222; color: white; margin-bottom: 10px; }
Â  Â  Â  Â  button { padding: 10px 20px; cursor: pointer; border: none; border-radius: 5px; font-weight: bold; font-size: 16px; transition: 0.2s; margin: 5px; }
Â  Â  Â  Â  button:disabled { background: #555; color: #aaa; cursor: not-allowed; }
Â  Â  Â  Â  .btn-create { background: #4CAF50; color: white; width: 100%; }
Â  Â  Â  Â  .btn-create:hover:not(:disabled) { background: #45a049; }
Â  Â  Â  Â  .btn-join { background: #2196F3; color: white; width: 45%; }
Â  Â  Â  Â  .btn-join:hover:not(:disabled) { background: #1e88e5; }
Â  Â  Â  Â  .btn-single { background: #FF9800; color: white; width: 100%; margin-bottom: 15px; }
Â  Â  Â  Â  .btn-single:hover:not(:disabled) { background: #F57C00; }
Â  Â  Â  Â  .btn-reset { background: #d32f2f; color: white; font-size: 12px; padding: 5px 10px; margin-top: 10px; }
Â  Â  Â  Â  .btn-play { background: #9C27B0; color: white; margin-top: 15px; width: 100%; }
Â  Â  Â  Â  .btn-play:hover:not(:disabled) { background: #7B1FA2; }
Â  Â  Â  Â Â 
Â  Â  Â  Â  #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; transform: translate(-50%, -50%); pointer-events: none; z-index: 10; display: none; }
Â  Â  Â  Â  #crosshair::before, #crosshair::after { content: ''; position: absolute; background: rgba(255, 255, 255, 0.8); }
Â  Â  Â  Â  #crosshair::before { top: 9px; left: 0; width: 20px; height: 2px; }
Â  Â  Â  Â  #crosshair::after { top: 0; left: 9px; width: 2px; height: 20px; }
Â  Â  Â  Â Â 
Â  Â  Â  Â  #hud { position: absolute; top: 10px; right: 10px; font-size: 14px; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; pointer-events: none; display: none; z-index: 15; text-align: right; }
Â  Â  Â  Â  .key { display: inline-block; padding: 2px 6px; background: #555; border-radius: 3px; border-bottom: 2px solid #333; }
Â  Â  Â  Â Â 
Â  Â  Â  Â  #copy-btn { font-size: 12px; padding: 5px; background: #555; color: white; border: none; cursor: pointer; display: none; margin-left: 5px; }
Â  Â  Â  Â  #notification { position: absolute; top: 20px; right: 20px; padding: 10px 20px; background: rgba(33, 150, 243, 0.9); color: white; border-radius: 5px; transform: translateX(200%); transition: transform 0.3s ease-in-out; z-index: 100; }
Â  Â  Â  Â Â 
Â  Â  Â  Â  #webgl-error { display: none !important; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; color: red; z-index: 999; flex-direction: column; align-items: center; justify-content: center; text-align: center; }
Â  Â  Â  Â Â 
Â  Â  Â  Â  #debug-info { position: absolute; top: 60px; left: 10px; color: yellow; font-family: monospace; font-size: 12px; pointer-events: none; z-index: 4; text-align: left; }
Â  Â  Â  Â  #network-log { position: absolute; top: 80px; left: 10px; color: lime; font-family: monospace; font-size: 10px; pointer-events: none; z-index: 4; text-align: left; opacity: 0.8; max-height: 200px; overflow: hidden; text-shadow: 1px 1px 1px black; background: rgba(0,0,0,0.3); padding: 5px; width: 300px; }
Â  Â  Â  Â Â 
Â  Â  Â  Â  #inventory { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); display: flex; gap: 5px; background: rgba(0,0,0,0.5); padding: 5px; border-radius: 5px; z-index: 15; display: none; }
Â  Â  Â  Â  .slot { width: 40px; height: 40px; border: 2px solid #555; cursor: pointer; background-size: cover; image-rendering: pixelated; position: relative; }
Â  Â  Â  Â  .slot.active { border-color: #fff; transform: scale(1.1); box-shadow: 0 0 10px rgba(255,255,255,0.5); }
Â  Â  Â  Â  .slot span { position: absolute; top: 0; left: 2px; font-size: 10px; color: white; text-shadow: 1px 1px 0 #000; }
Â  Â  Â  Â Â 
Â  Â  Â  Â  .mobile-controls { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 14; }
Â  Â  Â  Â  .touch-zone { pointer-events: auto; position: absolute; }
Â  Â  Â  Â  #joystick-zone { bottom: 20px; left: 20px; width: 150px; height: 150px; }
Â  Â  Â  Â  #joystick-bg { width: 120px; height: 120px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.3); border-radius: 50%; position: absolute; top: 15px; left: 15px; }
Â  Â  Â  Â  #joystick-stick { width: 50px; height: 50px; background: rgba(255,255,255,0.5); border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
Â  Â  Â  Â  .action-btn { position: absolute; width: 60px; height: 60px; background: rgba(0,0,0,0.3); border: 2px solid rgba(255,255,255,0.3); border-radius: 50%; color: white; font-weight: bold; display: flex; align-items: center; justify-content: center; font-size: 12px; pointer-events: auto; user-select: none; }
Â  Â  Â  Â  .action-btn:active { background: rgba(255,255,255,0.2); }
Â  Â  Â  Â  #btn-jump { bottom: 160px; right: 20px; }
Â  Â  Â  Â  #btn-place { bottom: 90px; right: 20px; background: rgba(76, 175, 80, 0.4); }
Â  Â  Â  Â  #btn-break { bottom: 20px; right: 20px; background: rgba(244, 67, 54, 0.4); }
Â  Â  Â  Â  #btn-fly { bottom: 230px; right: 20px; background: rgba(0, 255, 255, 0.3); font-size: 16px; }
Â  Â  Â  Â  #btn-down { bottom: 230px; right: 90px; display: none; }
Â  Â  Â  Â  #btn-cam { top: 60px; right: 20px; width: 40px; height: 40px; font-size: 10px; }
Â  Â  Â  Â  #mobile-toggle-btn { top: 10px; left: 10px; width: 40px; height: 40px; font-size: 20px; z-index: 50; background: rgba(0,0,0,0.5); border-radius: 10px; cursor: pointer; display: flex; align-items: center; justify-content: center; color: white;}
Â  Â  Â  Â  #look-zone { top: 0; right: 0; width: 60%; height: 80%; }
Â  Â  Â  Â Â 
Â  Â  Â  Â  #net-status { color: #aaa; margin-bottom: 5px; font-weight: bold; }
Â  Â  Â  Â  #net-status.online { color: #00ff00; }
Â  Â  Â  Â  #flight-status { position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%); color: #00FFFF; font-weight: bold; text-shadow: 1px 1px 2px black; display: none; pointer-events: none; }
Â  Â  </style>
</head>
<body>
Â  Â  <div id="webgl-error"><h1>ĞÑˆĞ¸Ğ±ĞºĞ° WebGL</h1><p>ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ±Ñ€Ğ°ÑƒĞ·ĞµÑ€ Ğ¸Ğ»Ğ¸ Ğ´Ñ€Ğ°Ğ¹Ğ²ĞµÑ€Ñ‹.</p></div>
Â  Â  <div id="debug-info">Blocks: 0</div>
Â  Â  <div id="network-log"></div>
Â  Â  <div id="flight-status">Ğ Ğ•Ğ–Ğ˜Ğœ ĞŸĞĞ›Ğ•Ğ¢Ğ</div>
Â  Â  <div id="mobile-toggle-btn" class="action-btn">ğŸ®</div>
Â  Â Â 
Â  Â  <div id="menu">
Â  Â  Â  Â  <div class="panel">
Â  Â  Â  Â  Â  Â  <h1>nblock</h1>
Â  Â  Â  Â  Â  Â  <p>v8.0 (Auto-Config & ICE Log)</p>
Â  Â  Â  Â  Â  Â  <div id="setup-controls">
Â  Â  Â  Â  Â  Â  Â  Â  <button class="btn-single" id="btn-single" onclick="startSinglePlayer(event)">ğŸ‘¤ ĞĞ´Ğ¸Ğ½Ğ¾Ñ‡Ğ½Ğ°Ñ Ğ¸Ğ³Ñ€Ğ°</button>
Â  Â  Â  Â  Â  Â  Â  Â  <div style="margin: 10px 0; border-top: 1px solid #555;"></div>
Â  Â  Â  Â  Â  Â  Â  Â  <button class="btn-create" id="btn-create" onclick="createGame(event)">ğŸŒ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ ÑĞµÑ€Ğ²ĞµÑ€</button>
Â  Â  Â  Â  Â  Â  Â  Â  <div style="margin-top: 10px; display: flex; justify-content: space-between;">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input type="text" id="remote-id" placeholder="ID Ğ´Ñ€ÑƒĞ³Ğ°" style="width: 45%; margin: 0;">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button class="btn-join" id="btn-join" onclick="joinGame(event)">Ğ’Ñ…Ğ¾Ğ´</button>
Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  <button class="btn-reset" onclick="resetNetwork(event)">âš  Ğ¡Ğ±Ñ€Ğ¾Ñ ÑĞµÑ‚Ğ¸</button>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  <div id="lobby-controls" style="display: none;">
Â  Â  Â  Â  Â  Â  Â  Â  <p>Ğ’Ğ°Ñˆ ID:</p>
Â  Â  Â  Â  Â  Â  Â  Â  <div style="display: flex; justify-content: center; align-items: center;">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input type="text" id="my-id" readonly style="width: 200px; text-align: center; margin: 0; background: #444;">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button id="copy-btn" onclick="copyId()">ĞšĞ¾Ğ¿.</button>
Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  <p class="status" id="status-msg">ĞĞ¶Ğ¸Ğ´Ğ°Ğ½Ğ¸Ğµ...</p>
Â  Â  Â  Â  Â  Â  Â  Â  <button class="btn-play" onclick="prepareGame(event)">Ğ˜Ğ³Ñ€Ğ°Ñ‚ÑŒ</button>
Â  Â  Â  Â  Â  Â  Â  Â  <button class="btn-reset" onclick="location.reload()">ĞœĞµĞ½Ñ</button>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>
Â  Â  </div>

Â  Â  <div id="blocker">
Â  Â  Â  Â  <div id="instructions">
Â  Â  Â  Â  Â  Â  ĞšĞ›Ğ˜ĞšĞĞ˜Ğ¢Ğ• Ğ§Ğ¢ĞĞ‘Ğ« Ğ˜Ğ“Ğ ĞĞ¢Ğ¬
Â  Â  Â  Â  Â  Â  <span>WASD - Ğ¥Ğ¾Ğ´Ğ¸Ñ‚ÑŒ, F - ĞŸĞ¾Ğ»ĞµÑ‚, SPACE - ĞŸÑ€Ñ‹Ğ¶Ğ¾Ğº</span>
Â  Â  Â  Â  Â  Â  <span>1-6 - Ğ‘Ğ»Ğ¾ĞºĞ¸</span>
Â  Â  Â  Â  </div>
Â  Â  </div>

Â  Â  <div id="crosshair"></div>
Â  Â  <div id="hud">
Â  Â  Â  Â  <div id="net-status">ĞÑ„Ğ»Ğ°Ğ¹Ğ½</div>
Â  Â  Â  Â  <span class="key">LKM</span> Ğ Ğ°Ğ·Ñ€ÑƒÑˆĞ¸Ñ‚ÑŒ <br> <span class="key">PKM</span> ĞŸĞ¾ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ <br> <span class="key">WASD</span> Ğ¥Ğ¾Ğ´Ğ¸Ñ‚ÑŒ <br> <span class="key">F</span> ĞŸĞ¾Ğ»ĞµÑ‚ <br> <span class="key">7</span> ĞšĞ°Ğ¼ĞµÑ€Ğ°
Â  Â  </div>
Â  Â  <div id="notification"></div>
Â  Â  <div id="inventory"></div>
Â  Â Â 
Â  Â  <div class="mobile-controls" id="mobile-ui">
Â  Â  Â  Â  <div id="look-zone" class="touch-zone"></div>
Â  Â  Â  Â  <div id="joystick-zone" class="touch-zone"><div id="joystick-bg"><div id="joystick-stick"></div></div></div>
Â  Â  Â  Â  <div id="btn-fly" class="action-btn">ğŸ•Šï¸</div>
Â  Â  Â  Â  <div id="btn-down" class="action-btn">â¬‡ï¸</div>
Â  Â  Â  Â  <div id="btn-jump" class="action-btn">JUMP</div>
Â  Â  Â  Â  <div id="btn-place" class="action-btn">BUILD</div>
Â  Â  Â  Â  <div id="btn-break" class="action-btn">BREAK</div>
Â  Â  Â  Â  <div id="btn-cam" class="action-btn">CAM</div>
Â  Â  </div>

Â  Â  <script>
Â  Â  Â  Â  function logNet(msg) {
Â  Â  Â  Â  Â  Â  console.log(msg);
Â  Â  Â  Â  Â  Â  const el = document.getElementById('network-log');
Â  Â  Â  Â  Â  Â  if(el.innerHTML.length > 800) el.innerHTML = "";
Â  Â  Â  Â  Â  Â  el.innerHTML = `> ${msg}<br>` + el.innerHTML;
Â  Â  Â  Â  }

Â  Â  Â  Â  let renderer, scene, camera;
Â  Â  Â  Â  const fpsElem = document.getElementById('debug-info');
Â  Â  Â  Â  const worldActionLog = [];Â 
Â  Â  Â  Â  let isGameActive = false;
Â  Â  Â  Â  let isHost = false;
Â  Â  Â  Â  let otherPlayerTargetPos = new THREE.Vector3(0, -100, 0);
Â  Â  Â  Â  let otherPlayerTargetRot = 0;

Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
Â  Â  Â  Â  Â  Â  renderer.setSize(window.innerWidth, window.innerHeight);
Â  Â  Â  Â  Â  Â  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
Â  Â  Â  Â  Â  Â  renderer.shadowMap.enabled = true;
Â  Â  Â  Â  Â  Â  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
Â  Â  Â  Â  Â  Â  document.body.appendChild(renderer.domElement);
Â  Â  Â  Â  Â  Â  scene = new THREE.Scene();
Â  Â  Â  Â  Â  Â  scene.background = new THREE.Color(0x87CEEB);
Â  Â  Â  Â  Â  Â  scene.fog = new THREE.Fog(0x87CEEB, 30, 90);
Â  Â  Â  Â  Â  Â  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
Â  Â  Â  Â  } catch (e) { document.getElementById('webgl-error').style.display = 'flex'; console.error(e); }

Â  Â  Â  Â  function createBlockTexture(color, noise = 0.1) {
Â  Â  Â  Â  Â  Â  const size = 32;
Â  Â  Â  Â  Â  Â  const canvas = document.createElement('canvas');
Â  Â  Â  Â  Â  Â  canvas.width = size; canvas.height = size;
Â  Â  Â  Â  Â  Â  const ctx = canvas.getContext('2d');
Â  Â  Â  Â  Â  Â  ctx.fillStyle = color; ctx.fillRect(0,0,size,size);
Â  Â  Â  Â  Â  Â  for(let i=0; i<100; i++) { ctx.fillStyle = `rgba(0,0,0,${Math.random()*noise})`; ctx.fillRect(Math.random()*size, Math.random()*size, 2, 2); }
Â  Â  Â  Â  Â  Â  const tex = new THREE.CanvasTexture(canvas);
Â  Â  Â  Â  Â  Â  tex.magFilter = THREE.NearestFilter;
Â  Â  Â  Â  Â  Â  tex.minFilter = THREE.NearestFilter;
Â  Â  Â  Â  Â  Â  tex.userData = { image: canvas };
Â  Â  Â  Â  Â  Â  return tex;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  const textures = {
Â  Â  Â  Â  Â  Â  grass: createBlockTexture('#5da130', 0.12),
Â  Â  Â  Â  Â  Â  dirt: createBlockTexture('#8b5a2b', 0.2),
Â  Â  Â  Â  Â  Â  stone: createBlockTexture('#7a7a7a', 0.2),
Â  Â  Â  Â  Â  Â  wood: createBlockTexture('#a05f2a', 0.1),
Â  Â  Â  Â  Â  Â  leaves: createBlockTexture('#3a7a1a', 0.2),
Â  Â  Â  Â  Â  Â  sand: createBlockTexture('#E6C288', 0.12)
Â  Â  Â  Â  };
Â  Â  Â  Â  const blockTypes = ['grass', 'dirt', 'stone', 'wood', 'leaves', 'sand'];
Â  Â  Â  Â  let selectedBlock = 'grass';
Â  Â  Â  Â  const materials = {
Â  Â  Â  Â  Â  Â  grass: new THREE.MeshLambertMaterial({ map: textures.grass }),
Â  Â  Â  Â  Â  Â  dirt: new THREE.MeshLambertMaterial({ map: textures.dirt }),
Â  Â  Â  Â  Â  Â  stone: new THREE.MeshLambertMaterial({ map: textures.stone }),
Â  Â  Â  Â  Â  Â  wood: new THREE.MeshLambertMaterial({ map: textures.wood }),
Â  Â  Â  Â  Â  Â  leaves: new THREE.MeshLambertMaterial({ map: textures.leaves, transparent: true, alphaTest: 0.5 }),
Â  Â  Â  Â  Â  Â  sand: new THREE.MeshLambertMaterial({ map: textures.sand }),
Â  Â  Â  Â  };
Â  Â  Â  Â  const otherPlayerMat = new THREE.MeshLambertMaterial({ color: 0xff4444 });
Â  Â  Â  Â  const localPlayerMat = new THREE.MeshLambertMaterial({ color: 0x4444ff });
Â  Â  Â  Â  const skinMat = new THREE.MeshLambertMaterial({ color: 0xffccaa });

Â  Â  Â  Â  const MAX_INSTANCES = 60000;
Â  Â  Â  Â  const dummy = new THREE.Object3D();
Â  Â  Â  Â  const geometry = new THREE.BoxGeometry(1, 1, 1);
Â  Â  Â  Â  const chunks = {};Â 
Â  Â  Â  Â  const worldData = new Map();
Â  Â  Â  Â Â 
Â  Â  Â  Â  const invContainer = document.getElementById('inventory');
Â  Â  Â  Â  blockTypes.forEach((type, index) => {
Â  Â  Â  Â  Â  Â  const slot = document.createElement('div');
Â  Â  Â  Â  Â  Â  slot.className = 'slot';
Â  Â  Â  Â  Â  Â  if (index === 0) slot.classList.add('active');
Â  Â  Â  Â  Â  Â  slot.style.backgroundImage = `url(${textures[type].userData.image.toDataURL()})`;
Â  Â  Â  Â  Â  Â  slot.innerHTML = `<span>${index + 1}</span>`;
Â  Â  Â  Â  Â  Â  slot.onclick = () => selectBlock(type, slot);
Â  Â  Â  Â  Â  Â  invContainer.appendChild(slot);
Â  Â  Â  Â  });

Â  Â  Â  Â  function selectBlock(type, slotElement = null) {
Â  Â  Â  Â  Â  Â  selectedBlock = type;
Â  Â  Â  Â  Â  Â  const slots = document.querySelectorAll('.slot');
Â  Â  Â  Â  Â  Â  slots.forEach(s => s.classList.remove('active'));
Â  Â  Â  Â  Â  Â  if (slotElement) { slotElement.classList.add('active'); }Â 
Â  Â  Â  Â  Â  Â  else { const idx = blockTypes.indexOf(type); if(slots[idx]) slots[idx].classList.add('active'); }
Â  Â  Â  Â  }
Â  Â  Â  Â  document.addEventListener('keydown', (e) => {
Â  Â  Â  Â  Â  Â  const key = parseInt(e.key);
Â  Â  Â  Â  Â  Â  if (key >= 1 && key <= 6) selectBlock(blockTypes[key - 1]);
Â  Â  Â  Â  });

Â  Â  Â  Â  for (const type in materials) {
Â  Â  Â  Â  Â  Â  const mesh = new THREE.InstancedMesh(geometry, materials[type], MAX_INSTANCES);
Â  Â  Â  Â  Â  Â  mesh.count = 0; mesh.castShadow = false; mesh.receiveShadow = true; mesh.frustumCulled = false;
Â  Â  Â  Â  Â  Â  scene.add(mesh); chunks[type] = mesh;
Â  Â  Â  Â  }

Â  Â  Â  Â  function sendData(data) {
Â  Â  Â  Â  Â  Â  if (conn && conn.open) {
Â  Â  Â  Â  Â  Â  Â  Â  try { conn.send(data); } catch (e) { console.error("Send error:", e); }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  function addBlock(x, y, z, type, isRemote = false) {
Â  Â  Â  Â  Â  Â  const key = `${x},${y},${z}`;
Â  Â  Â  Â  Â  Â  if (worldData.has(key)) return;
Â  Â  Â  Â  Â  Â  const mesh = chunks[type];
Â  Â  Â  Â  Â  Â  if (mesh.count >= MAX_INSTANCES) return;
Â  Â  Â  Â  Â  Â  dummy.position.set(x, y, z);
Â  Â  Â  Â  Â  Â  dummy.updateMatrix();
Â  Â  Â  Â  Â  Â  mesh.setMatrixAt(mesh.count, dummy.matrix);
Â  Â  Â  Â  Â  Â  worldData.set(key, { type: type, instanceId: mesh.count });
Â  Â  Â  Â  Â  Â  mesh.count++;
Â  Â  Â  Â  Â  Â  mesh.instanceMatrix.needsUpdate = true;
Â  Â  Â  Â  Â  Â  updateDebug();
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  if (isHost && isRemote) { worldActionLog.push({ type: 'add', x, y, z, blockType: type }); }
Â  Â  Â  Â  Â  Â  if (!isRemote) {
Â  Â  Â  Â  Â  Â  Â  Â  const action = { type: 'add', x, y, z, blockType: type };
Â  Â  Â  Â  Â  Â  Â  Â  if (isHost) worldActionLog.push(action);Â 
Â  Â  Â  Â  Â  Â  Â  Â  sendData({ type: 'block_add', ...action });
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  function removeBlock(x, y, z, isRemote = false) {
Â  Â  Â  Â  Â  Â  const key = `${x},${y},${z}`;
Â  Â  Â  Â  Â  Â  const data = worldData.get(key);
Â  Â  Â  Â  Â  Â  if (!data) return;
Â  Â  Â  Â  Â  Â  const mesh = chunks[data.type];
Â  Â  Â  Â  Â  Â  const idToRemove = data.instanceId;
Â  Â  Â  Â  Â  Â  const lastId = mesh.count - 1;
Â  Â  Â  Â  Â  Â  const lastMatrix = new THREE.Matrix4();
Â  Â  Â  Â  Â  Â  mesh.getMatrixAt(lastId, lastMatrix);
Â  Â  Â  Â  Â  Â  mesh.setMatrixAt(idToRemove, lastMatrix);
Â  Â  Â  Â  Â  Â  const pos = new THREE.Vector3();
Â  Â  Â  Â  Â  Â  lastMatrix.decompose(pos, new THREE.Quaternion(), new THREE.Vector3());
Â  Â  Â  Â  Â  Â  const lastKey = `${Math.round(pos.x)},${Math.round(pos.y)},${Math.round(pos.z)}`;
Â  Â  Â  Â  Â  Â  if (lastId !== idToRemove) {
Â  Â  Â  Â  Â  Â  Â  Â  const lastBlockData = worldData.get(lastKey);
Â  Â  Â  Â  Â  Â  Â  Â  if (lastBlockData) lastBlockData.instanceId = idToRemove;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  worldData.delete(key);
Â  Â  Â  Â  Â  Â  mesh.count--;
Â  Â  Â  Â  Â  Â  mesh.instanceMatrix.needsUpdate = true;
Â  Â  Â  Â  Â  Â  updateDebug();
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  if (isHost && isRemote) { worldActionLog.push({ type: 'remove', x, y, z }); }
Â  Â  Â  Â  Â  Â  if (!isRemote) {
Â  Â  Â  Â  Â  Â  Â  Â  const action = { type: 'remove', x, y, z };
Â  Â  Â  Â  Â  Â  Â  Â  if (isHost) worldActionLog.push(action);
Â  Â  Â  Â  Â  Â  Â  Â  sendData({ type: 'block_remove', ...action });
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  function updateDebug() { fpsElem.innerText = `Blocks: ${worldData.size}`; }
Â  Â  Â  Â Â 
Â  Â  Â  Â  const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x444444, 0.6);
Â  Â  Â  Â  hemiLight.position.set(0, 50, 0); scene.add(hemiLight);
Â  Â  Â  Â  const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
Â  Â  Â  Â  dirLight.position.set(50, 100, 50); dirLight.castShadow = true;
Â  Â  Â  Â  dirLight.shadow.mapSize.width = 1024; dirLight.shadow.mapSize.height = 1024;
Â  Â  Â  Â  dirLight.shadow.camera.near = 0.5; dirLight.shadow.camera.far = 200;
Â  Â  Â  Â  dirLight.shadow.camera.left = -50; dirLight.shadow.camera.right = 50;
Â  Â  Â  Â  dirLight.shadow.camera.top = 50; dirLight.shadow.camera.bottom = -50;
Â  Â  Â  Â  scene.add(dirLight);

Â  Â  Â  Â  const waterGeo = new THREE.PlaneGeometry(1000, 1000);
Â  Â  Â  Â  const waterMat = new THREE.MeshBasicMaterial({ color: 0x1E90FF, transparent: true, opacity: 0.6, side: THREE.DoubleSide });
Â  Â  Â  Â  const water = new THREE.Mesh(waterGeo, waterMat);
Â  Â  Â  Â  water.rotation.x = -Math.PI / 2; water.position.y = 1.2; scene.add(water);
Â  Â  Â  Â  const WORLD_RADIUS = 50;Â 
Â  Â  Â  Â Â 
Â  Â  Â  Â  function pseudoRandom(x, z) { return Math.abs(Math.sin(x * 12.9898 + z * 78.233) * 43758.5453) % 1; }

Â  Â  Â  Â  function createTree(x, y, z) {
Â  Â  Â  Â  Â  Â  const h = 4 + Math.floor(pseudoRandom(x, z) * 2);
Â  Â  Â  Â  Â  Â  for(let i=0; i<h; i++) addBlock(x, y+i, z, 'wood', true);
Â  Â  Â  Â  Â  Â  for(let lx=x-2; lx<=x+2; lx++) {
Â  Â  Â  Â  Â  Â  Â  Â  for(let lz=z-2; lz<=z+2; lz++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for(let ly=y+h-2; ly<=y+h+1; ly++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(Math.abs(lx-x)===2 && Math.abs(lz-z)===2) continue;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(lx===x && lz===z && ly<y+h) continue;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(pseudoRandom(lx, ly+lz) > 0.2) addBlock(lx, ly, lz, 'leaves', true);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  function generateWorld() {
Â  Â  Â  Â  Â  Â  for (let x = -WORLD_RADIUS - 5; x <= WORLD_RADIUS + 5; x++) {
Â  Â  Â  Â  Â  Â  Â  Â  for (let z = -WORLD_RADIUS - 5; z <= WORLD_RADIUS + 5; z++) { addBlock(x, 0, z, 'sand', true); }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  for (let x = -WORLD_RADIUS; x <= WORLD_RADIUS; x++) {
Â  Â  Â  Â  Â  Â  Â  Â  for (let z = -WORLD_RADIUS; z <= WORLD_RADIUS; z++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const dist = Math.sqrt(x*x + z*z);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const islandFactor = Math.max(0, 1 - Math.pow(dist / (WORLD_RADIUS - 2), 2));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (islandFactor > 0.1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let h = Math.floor(7 * islandFactor * Math.sin(x/9) * Math.cos(z/9));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  h += 4;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let type;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const isSurface = true;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(isSurface) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let y = 1; y <= h; y++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (y === h) { if (y <= 2) type = 'sand'; else type = 'grass'; }Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  else if (y > h - 4) { type = 'dirt'; } else { type = 'stone'; }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (type === 'stone' && y < h-3 && x%2!==0 && z%2!==0) continue;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  addBlock(x, y, z, type, true);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (pseudoRandom(x, z) < 0.015 && h > 2) { createTree(x, h + 1, z); }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  generateWorld();
Â  Â  Â  Â Â 
Â  Â  Â  Â  const controls = new THREE.PointerLockControls(camera, document.body);
Â  Â  Â  Â  const player = { velocity: new THREE.Vector3(), direction: new THREE.Vector3() };
Â  Â  Â  Â  let moveFwd = false, moveBwd = false, moveLeft = false, moveRight = false;
Â  Â  Â  Â  let moveUp = false, moveDown = false;
Â  Â  Â  Â  let canJump = false; let isFlying = false;
Â  Â  Â  Â Â 
Â  Â  Â  Â  function createPlayerModel(isLocal) {
Â  Â  Â  Â  Â  Â  const group = new THREE.Group();
Â  Â  Â  Â  Â  Â  const mat = isLocal ? localPlayerMat : otherPlayerMat;
Â  Â  Â  Â  Â  Â  const limbs = {};
Â  Â  Â  Â  Â  Â  const legGeo = new THREE.BoxGeometry(0.25, 0.8, 0.25);
Â  Â  Â  Â  Â  Â  legGeo.translate(0, -0.3, 0);Â 
Â  Â  Â  Â  Â  Â  const legL = new THREE.Mesh(legGeo, mat);
Â  Â  Â  Â  Â  Â  legL.position.set(-0.15, 0.7, 0);Â 
Â  Â  Â  Â  Â  Â  group.add(legL); limbs.legL = legL;
Â  Â  Â  Â  Â  Â  const legR = new THREE.Mesh(legGeo, mat);
Â  Â  Â  Â  Â  Â  legR.position.set(0.15, 0.7, 0);
Â  Â  Â  Â  Â  Â  group.add(legR); limbs.legR = legR;
Â  Â  Â  Â  Â  Â  const bodyGeo = new THREE.BoxGeometry(0.5, 0.8, 0.25);
Â  Â  Â  Â  Â  Â  const body = new THREE.Mesh(bodyGeo, mat);
Â  Â  Â  Â  Â  Â  body.position.y = 1.2; group.add(body);
Â  Â  Â  Â  Â  Â  const armGeo = new THREE.BoxGeometry(0.2, 0.8, 0.2);
Â  Â  Â  Â  Â  Â  armGeo.translate(0, -0.3, 0);
Â  Â  Â  Â  Â  Â  const armL = new THREE.Mesh(armGeo, mat);
Â  Â  Â  Â  Â  Â  armL.position.set(-0.4, 1.5, 0);
Â  Â  Â  Â  Â  Â  group.add(armL); limbs.armL = armL;
Â  Â  Â  Â  Â  Â  const armR = new THREE.Mesh(armGeo, mat);
Â  Â  Â  Â  Â  Â  armR.position.set(0.4, 1.5, 0);
Â  Â  Â  Â  Â  Â  group.add(armR); limbs.armR = armR;
Â  Â  Â  Â  Â  Â  const headGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
Â  Â  Â  Â  Â  Â  const head = new THREE.Mesh(headGeo, skinMat);
Â  Â  Â  Â  Â  Â  head.position.y = 1.8; group.add(head);
Â  Â  Â  Â  Â  Â  group.userData.limbs = limbs;
Â  Â  Â  Â  Â  Â  return group;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  let isThirdPerson = false;
Â  Â  Â  Â  const localPlayerGroup = createPlayerModel(true);
Â  Â  Â  Â  scene.add(localPlayerGroup); localPlayerGroup.visible = false;
Â  Â  Â  Â  const otherPlayerGroup = createPlayerModel(false);
Â  Â  Â  Â  scene.add(otherPlayerGroup); otherPlayerGroup.position.set(0, -100, 0);
Â  Â  Â  Â Â 
Â  Â  Â  Â  function animateCharacter(group, isMoving, time) {
Â  Â  Â  Â  Â  Â  const limbs = group.userData.limbs;
Â  Â  Â  Â  Â  Â  if (!limbs) return;
Â  Â  Â  Â  Â  Â  if (isMoving) {
Â  Â  Â  Â  Â  Â  Â  Â  const speed = 10;
Â  Â  Â  Â  Â  Â  Â  Â  const angle = Math.sin(time * speed) * 0.8;
Â  Â  Â  Â  Â  Â  Â  Â  limbs.legL.rotation.x = angle; limbs.legR.rotation.x = -angle;
Â  Â  Â  Â  Â  Â  Â  Â  limbs.armL.rotation.x = -angle; limbs.armR.rotation.x = angle;
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  limbs.legL.rotation.x = 0; limbs.legR.rotation.x = 0;
Â  Â  Â  Â  Â  Â  Â  Â  limbs.armL.rotation.x = 0; limbs.armR.rotation.x = 0;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  const onKey = (e, v) => {
Â  Â  Â  Â  Â  Â  switch(e.code) {
Â  Â  Â  Â  Â  Â  Â  Â  case 'KeyW': moveFwd = v; break;
Â  Â  Â  Â  Â  Â  Â  Â  case 'KeyS': moveBwd = v; break;
Â  Â  Â  Â  Â  Â  Â  Â  case 'KeyA': moveLeft = v; break;
Â  Â  Â  Â  Â  Â  Â  Â  case 'KeyD': moveRight = v; break;
Â  Â  Â  Â  Â  Â  Â  Â  case 'Space':Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (isFlying) moveUp = v;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  else if(v && canJump) { player.velocity.y = 12; canJump = false; }Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  case 'ShiftLeft': if (isFlying) moveDown = v; break;
Â  Â  Â  Â  Â  Â  Â  Â  case 'Digit7': if(v) toggleCameraMode(); break;Â 
Â  Â  Â  Â  Â  Â  Â  Â  case 'KeyF': if(v) toggleFlight(); break;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  };
Â  Â  Â  Â  document.addEventListener('keydown', e => onKey(e, true));
Â  Â  Â  Â  document.addEventListener('keyup', e => onKey(e, false));
Â  Â  Â  Â Â 
Â  Â  Â  Â  function toggleCameraMode() {
Â  Â  Â  Â  Â  Â  isThirdPerson = !isThirdPerson;
Â  Â  Â  Â  Â  Â  localPlayerGroup.visible = isThirdPerson;
Â  Â  Â  Â  Â  Â  document.getElementById('crosshair').style.display = (isThirdPerson || isMobile) ? 'none' : 'block';
Â  Â  Â  Â  }

Â  Â  Â  Â  function toggleFlight() {
Â  Â  Â  Â  Â  Â  isFlying = !isFlying; player.velocity.y = 0;Â 
Â  Â  Â  Â  Â  Â  document.getElementById('flight-status').style.display = isFlying ? 'block' : 'none';
Â  Â  Â  Â  Â  Â  document.getElementById('btn-down').style.display = (isMobile && isFlying) ? 'flex' : 'none';
Â  Â  Â  Â  Â  Â  showNotification(isFlying ? "ĞŸĞ¾Ğ»ĞµÑ‚ Ğ’ĞšĞ›" : "ĞŸĞ¾Ğ»ĞµÑ‚ Ğ’Ğ«ĞšĞ›");
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  let isMobile = false;
Â  Â  Â  Â  if ('ontouchstart' in window || navigator.maxTouchPoints > 0) enableMobileUI();
Â  Â  Â  Â  const mobileToggleBtn = document.getElementById('mobile-toggle-btn');
Â  Â  Â  Â  const handleToggle = (e) => {
Â  Â  Â  Â  Â  Â  Â e.preventDefault(); e.stopPropagation();
Â  Â  Â  Â  Â  Â  Â const ui = document.getElementById('mobile-ui');
Â  Â  Â  Â  Â  Â  Â if (ui.style.display === 'block') ui.style.display = 'none';
Â  Â  Â  Â  Â  Â  Â else enableMobileUI();
Â  Â  Â  Â  };
Â  Â  Â  Â  mobileToggleBtn.addEventListener('click', handleToggle);
Â  Â  Â  Â  mobileToggleBtn.addEventListener('touchstart', handleToggle);
Â  Â  Â  Â Â 
Â  Â  Â  Â  function enableMobileUI() {
Â  Â  Â  Â  Â  Â  isMobile = true;
Â  Â  Â  Â  Â  Â  document.getElementById('mobile-ui').style.display = 'block';
Â  Â  Â  Â  Â  Â  document.getElementById('hud').style.display = 'none';
Â  Â  Â  Â  Â  Â  document.getElementById('crosshair').style.display = 'block';
Â  Â  Â  Â  Â  Â  document.getElementById('inventory').style.display = 'flex';Â 
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  const joystickStick = document.getElementById('joystick-stick');
Â  Â  Â  Â  const joystickZone = document.getElementById('joystick-zone');
Â  Â  Â  Â  let joyTouchId = null; let joyStartX = 0, joyStartY = 0;
Â  Â  Â  Â  joystickZone.addEventListener('touchstart', (e) => {
Â  Â  Â  Â  Â  Â  e.preventDefault(); const touch = e.changedTouches[0]; joyTouchId = touch.identifier; joyStartX = touch.clientX; joyStartY = touch.clientY;
Â  Â  Â  Â  }, {passive: false});
Â  Â  Â  Â  joystickZone.addEventListener('touchmove', (e) => {
Â  Â  Â  Â  Â  Â  e.preventDefault(); for(let i=0; i<e.changedTouches.length; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  if(e.changedTouches[i].identifier === joyTouchId) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const touch = e.changedTouches[i];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let dx = touch.clientX - joyStartX; let dy = touch.clientY - joyStartY;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const dist = Math.sqrt(dx*dx + dy*dy); const maxDist = 40;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(dist > maxDist) { dx = (dx/dist)*maxDist; dy = (dy/dist)*maxDist; }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  joystickStick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  moveRight = (dx/maxDist) > 0.2; moveLeft = (dx/maxDist) < -0.2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  moveBwd = (dy/maxDist) > 0.2; moveFwd = (dy/maxDist) < -0.2;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }, {passive: false});
Â  Â  Â  Â  const resetJoystick = () => { joyTouchId = null; joystickStick.style.transform = `translate(-50%, -50%)`; moveFwd = moveBwd = moveLeft = moveRight = false; };
Â  Â  Â  Â  joystickZone.addEventListener('touchend', resetJoystick); joystickZone.addEventListener('touchcancel', resetJoystick);
Â  Â  Â  Â Â 
Â  Â  Â  Â  const lookZone = document.getElementById('look-zone');
Â  Â  Â  Â  let lookTouchId = null; let lookLastX = 0, lookLastY = 0;
Â  Â  Â  Â  lookZone.addEventListener('touchstart', (e) => {
Â  Â  Â  Â  Â  Â  const touch = e.changedTouches[0]; lookTouchId = touch.identifier; lookLastX = touch.clientX; lookLastY = touch.clientY;
Â  Â  Â  Â  });
Â  Â  Â  Â  lookZone.addEventListener('touchmove', (e) => {
Â  Â  Â  Â  Â  Â  e.preventDefault(); for(let i=0; i<e.changedTouches.length; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  if(e.changedTouches[i].identifier === lookTouchId) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const touch = e.changedTouches[i];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const dx = touch.clientX - lookLastX; const dy = touch.clientY - lookLastY;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lookLastX = touch.clientX; lookLastY = touch.clientY;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const euler = new THREE.Euler(0, 0, 0, 'YXZ');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  euler.setFromQuaternion(camera.quaternion);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  euler.y -= dx * 0.005; euler.x -= dy * 0.005;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  euler.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, euler.x));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  camera.quaternion.setFromEuler(euler);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }, {passive: false});
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Mobile Buttons Logic
Â  Â  Â  Â  const btnJump = document.getElementById('btn-jump');
Â  Â  Â  Â  const btnFly = document.getElementById('btn-fly');
Â  Â  Â  Â  const btnDown = document.getElementById('btn-down');

Â  Â  Â  Â  btnJump.addEventListener('touchstart', (e) => {
Â  Â  Â  Â  Â  Â  e.preventDefault();Â 
Â  Â  Â  Â  Â  Â  if (isFlying) moveUp = true;
Â  Â  Â  Â  Â  Â  else if(canJump) { player.velocity.y = 12; canJump=false; }
Â  Â  Â  Â  });
Â  Â  Â  Â  btnJump.addEventListener('touchend', (e) => {
Â  Â  Â  Â  Â  Â  e.preventDefault();Â 
Â  Â  Â  Â  Â  Â  if (isFlying) moveUp = false;
Â  Â  Â  Â  });

Â  Â  Â  Â  btnDown.addEventListener('touchstart', (e) => {
Â  Â  Â  Â  Â  Â  e.preventDefault();Â 
Â  Â  Â  Â  Â  Â  if (isFlying) moveDown = true;
Â  Â  Â  Â  });
Â  Â  Â  Â  btnDown.addEventListener('touchend', (e) => {
Â  Â  Â  Â  Â  Â  e.preventDefault();Â 
Â  Â  Â  Â  Â  Â  if (isFlying) moveDown = false;
Â  Â  Â  Â  });

Â  Â  Â  Â  btnFly.addEventListener('touchstart', (e) => {
Â  Â  Â  Â  Â  Â  e.preventDefault();Â 
Â  Â  Â  Â  Â  Â  toggleFlight();
Â  Â  Â  Â  });

Â  Â  Â  Â  document.getElementById('btn-cam').addEventListener('touchstart', (e)=>{e.preventDefault(); toggleCameraMode();});
Â  Â  Â  Â  document.getElementById('btn-place').addEventListener('touchstart', (e)=>{e.preventDefault(); performRaycastAction(2);});
Â  Â  Â  Â  document.getElementById('btn-break').addEventListener('touchstart', (e)=>{e.preventDefault(); performRaycastAction(0);});

Â  Â  Â  Â  const raycaster = new THREE.Raycaster(); raycaster.far = 6; const center = new THREE.Vector2(0,0);
Â  Â  Â  Â  function performRaycastAction(buttonType) {
Â  Â  Â  Â  Â  Â  raycaster.setFromCamera(center, camera);
Â  Â  Â  Â  Â  Â  const meshesToCheck = Object.values(chunks);
Â  Â  Â  Â  Â  Â  const intersects = raycaster.intersectObjects(meshesToCheck);
Â  Â  Â  Â  Â  Â  if(intersects.length > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  const hit = intersects[0];
Â  Â  Â  Â  Â  Â  Â  Â  const p = hit.point.clone().sub(hit.face.normal.clone().multiplyScalar(0.1));
Â  Â  Â  Â  Â  Â  Â  Â  const bx = Math.round(p.x), by = Math.round(p.y), bz = Math.round(p.z);
Â  Â  Â  Â  Â  Â  Â  Â  if(buttonType === 0) removeBlock(bx, by, bz);
Â  Â  Â  Â  Â  Â  Â  Â  else if (buttonType === 2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const p2 = hit.point.clone().add(hit.face.normal.clone().multiplyScalar(0.1));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const nx = Math.round(p2.x), ny = Math.round(p2.y), nz = Math.round(p2.z);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const pp = controls.getObject().position;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Math.abs(nx - pp.x) < 0.6 && Math.abs(nz - pp.z) < 0.6 && ny >= pp.y-2.0 && ny <= pp.y+0.2) return;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  addBlock(nx, ny, nz, selectedBlock);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  document.addEventListener('mousedown', e => { if(!isGameActive) return; if(!controls.isLocked && !isMobile) return; performRaycastAction(e.button); });
Â  Â  Â  Â Â 
Â  Â  Â  Â  function hasBlock(x, y, z) { return worldData.has(`${Math.round(x)},${Math.round(y)},${Math.round(z)}`); }
Â  Â  Â  Â  function checkPlayerHorizontalCollision(pos) {
Â  Â  Â  Â  Â  Â  if (isFlying) return false;
Â  Â  Â  Â  Â  Â  const w = 0.3; const h = 1.9;
Â  Â  Â  Â  Â  Â  const points = [
Â  Â  Â  Â  Â  Â  Â  Â  [pos.x-w, pos.y-h+0.2, pos.z-w], [pos.x+w, pos.y-h+0.2, pos.z-w],
Â  Â  Â  Â  Â  Â  Â  Â  [pos.x-w, pos.y-h+0.2, pos.z+w], [pos.x+w, pos.y-h+0.2, pos.z+w],
Â  Â  Â  Â  Â  Â  Â  Â  [pos.x-w, pos.y-1.0, pos.z-w], [pos.x+w, pos.y-1.0, pos.z-w],
Â  Â  Â  Â  Â  Â  Â  Â  [pos.x-w, pos.y-0.1, pos.z-w], [pos.x+w, pos.y-0.1, pos.z-w]
Â  Â  Â  Â  Â  Â  ];
Â  Â  Â  Â  Â  Â  for(let p of points) if(hasBlock(p[0], p[1], p[2])) return true;
Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  let prevTime = performance.now();
Â  Â  Â  Â  function animate() {
Â  Â  Â  Â  Â  Â  requestAnimationFrame(animate);
Â  Â  Â  Â  Â  Â  if(!renderer) return;
Â  Â  Â  Â  Â  Â  const time = performance.now();
Â  Â  Â  Â  Â  Â  const dt = Math.min((time - prevTime) / 1000, 0.1);
Â  Â  Â  Â  Â  Â  prevTime = time;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  if(isGameActive) {
Â  Â  Â  Â  Â  Â  Â  Â  const camObj = camera;Â 
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (isFlying) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const flySpeed = 25 * dt;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  player.velocity.y = 0;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (moveUp) camObj.position.y += flySpeed;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (moveDown) camObj.position.y -= flySpeed;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const right = new THREE.Vector3().crossVectors(dir, new THREE.Vector3(0,1,0));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (moveFwd) camObj.position.addScaledVector(dir, flySpeed);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (moveBwd) camObj.position.addScaledVector(dir, -flySpeed);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (moveRight) camObj.position.addScaledVector(right, flySpeed);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (moveLeft) camObj.position.addScaledVector(right, -flySpeed);
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!canJump) player.velocity.y -= 35 * dt;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  player.direction.z = Number(moveFwd) - Number(moveBwd);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  player.direction.x = Number(moveRight) - Number(moveLeft);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  player.direction.normalize();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (moveFwd || moveBwd) player.velocity.z += player.direction.z * 60 * dt;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (moveLeft || moveRight) player.velocity.x += player.direction.x * 60 * dt;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  player.velocity.x -= player.velocity.x * 10 * dt; player.velocity.z -= player.velocity.z * 10 * dt;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camObj.quaternion);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  forward.y = 0; forward.normalize();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camObj.quaternion);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  right.y = 0; right.normalize();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const vx = (forward.x * player.velocity.z + right.x * player.velocity.x) * dt;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const vz = (forward.z * player.velocity.z + right.z * player.velocity.x) * dt;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(checkPlayerHorizontalCollision(new THREE.Vector3(camObj.position.x + vx, camObj.position.y, camObj.position.z))) player.velocity.x = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  else camObj.position.x += vx;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(checkPlayerHorizontalCollision(new THREE.Vector3(camObj.position.x, camObj.position.y, camObj.position.z + vz))) player.velocity.z = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  else camObj.position.z += vz;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  camObj.position.y += player.velocity.y * dt;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const playerHeight = 1.8; const feetY = camObj.position.y - playerHeight; const blockY = Math.round(feetY - 0.5);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (hasBlock(camObj.position.x, blockY, camObj.position.z)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const blockTop = blockY + 0.5;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (player.velocity.y <= 0 && feetY < blockTop + 0.1) { camObj.position.y = blockTop + playerHeight; player.velocity.y = 0; canJump = true; }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else canJump = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (player.velocity.y > 0 && hasBlock(camObj.position.x, camObj.position.y + 0.1, camObj.position.z)) { player.velocity.y = 0; camObj.position.y -= 0.1; }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if(camObj.position.y < -30) { camObj.position.set(0, 15, 0); player.velocity.y = 0; }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  localPlayerGroup.position.x = camObj.position.x; localPlayerGroup.position.y = camObj.position.y - 1.8; localPlayerGroup.position.z = camObj.position.z;
Â  Â  Â  Â  Â  Â  Â  Â  const euler = new THREE.Euler(0, 0, 0, 'YXZ'); euler.setFromQuaternion(camObj.quaternion);
Â  Â  Â  Â  Â  Â  Â  Â  localPlayerGroup.rotation.y = euler.y;
Â  Â  Â  Â  Â  Â  Â  Â  const isMoving = Math.abs(player.velocity.x) > 0.1 || Math.abs(player.velocity.z) > 0.1 || (isFlying && (moveFwd||moveBwd));
Â  Â  Â  Â  Â  Â  Â  Â  animateCharacter(localPlayerGroup, isMoving, time / 1000);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  otherPlayerGroup.position.lerp(otherPlayerTargetPos, 0.1);Â 
Â  Â  Â  Â  Â  Â  otherPlayerGroup.rotation.y += (otherPlayerTargetRot - otherPlayerGroup.rotation.y) * 0.1;
Â  Â  Â  Â  Â  Â  const dist = otherPlayerGroup.position.distanceTo(otherPlayerTargetPos);
Â  Â  Â  Â  Â  Â  animateCharacter(otherPlayerGroup, dist > 0.05, time / 1000);
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  if (isThirdPerson && isGameActive) {
Â  Â  Â  Â  Â  Â  Â  Â  const originalPos = camera.position.clone();
Â  Â  Â  Â  Â  Â  Â  Â  const offset = new THREE.Vector3(0, 0, 5);Â 
Â  Â  Â  Â  Â  Â  Â  Â  offset.applyQuaternion(camera.quaternion);
Â  Â  Â  Â  Â  Â  Â  Â  camera.position.add(offset);
Â  Â  Â  Â  Â  Â  Â  Â  renderer.render(scene, camera);
Â  Â  Â  Â  Â  Â  Â  Â  camera.position.copy(originalPos);
Â  Â  Â  Â  Â  Â  } else renderer.render(scene, camera);
Â  Â  Â  Â  }
Â  Â  Â  Â  animate();

Â  Â  Â  Â  // --- Ğ¡ĞµÑ‚ĞµĞ²Ğ°Ñ Ñ‡Ğ°ÑÑ‚ÑŒ ---
Â  Â  Â  Â  let peer = null, conn = null;
Â  Â  Â  Â  let handshakeInterval = null;
Â  Â  Â  Â  let isConnected = false;

Â  Â  Â  Â  function updateUI(showMenu) {
Â  Â  Â  Â  Â  Â  document.getElementById('menu').style.display = showMenu ? 'flex' : 'none';
Â  Â  Â  Â  Â  Â  if (isMobile) {
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('blocker').style.display = 'none';Â 
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('inventory').style.display = showMenu ? 'none' : 'flex';
Â  Â  Â  Â  Â  Â  Â  Â  isGameActive = !showMenu;
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('blocker').style.display = showMenu ? 'none' : 'flex';
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('inventory').style.display = showMenu ? 'none' : 'flex';
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  const blocker = document.getElementById('blocker');
Â  Â  Â  Â  blocker.addEventListener('click', () => {
Â  Â  Â  Â  Â  Â  blocker.style.display = 'none';
Â  Â  Â  Â  Â  Â  document.getElementById('crosshair').style.display = isThirdPerson ? 'none' : 'block';
Â  Â  Â  Â  Â  Â  document.getElementById('hud').style.display = 'block';
Â  Â  Â  Â  Â  Â  document.getElementById('inventory').style.display = 'flex';
Â  Â  Â  Â  Â  Â  isGameActive = true;
Â  Â  Â  Â  Â  Â  try { if (document.pointerLockElement !== document.body) controls.lock(); } catch (e) {}
Â  Â  Â  Â  });
Â  Â  Â  Â  controls.addEventListener('lock', () => {
Â  Â  Â  Â  Â  Â  document.getElementById('blocker').style.display = 'none';
Â  Â  Â  Â  Â  Â  document.getElementById('crosshair').style.display = isThirdPerson ? 'none' : 'block';
Â  Â  Â  Â  Â  Â  document.getElementById('hud').style.display = 'block';
Â  Â  Â  Â  Â  Â  document.getElementById('inventory').style.display = 'flex';
Â  Â  Â  Â  Â  Â  isGameActive = true;
Â  Â  Â  Â  });
Â  Â  Â  Â  controls.addEventListener('unlock', () => {
Â  Â  Â  Â  Â  Â  if (document.getElementById('menu').style.display === 'none') {
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('blocker').style.display = 'flex';
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('crosshair').style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('hud').style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('inventory').style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  isGameActive = false;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });
Â  Â  Â  Â  function showNotification(msg) {
Â  Â  Â  Â  Â  Â  const n = document.getElementById('notification');
Â  Â  Â  Â  Â  Â  n.innerText = msg; n.style.transform = "translateX(0)";
Â  Â  Â  Â  Â  Â  setTimeout(() => n.style.transform = "translateX(200%)", 3000);
Â  Â  Â  Â  }
Â  Â  Â  Â  function startSinglePlayer(e) { e.stopPropagation(); updateUI(false); controls.getObject().position.set(0,15,0); isGameActive=true; }
Â  Â  Â  Â Â 
Â  Â  Â  Â  function resetNetwork(e) {
Â  Â  Â  Â  Â  Â  e.stopPropagation();
Â  Â  Â  Â  Â  Â  if(peer) peer.destroy();
Â  Â  Â  Â  Â  Â  if(conn) conn.close();
Â  Â  Â  Â  Â  Â  peer = null; conn = null;
Â  Â  Â  Â  Â  Â  document.getElementById('btn-join').disabled = false; document.getElementById('btn-join').innerText = "Ğ’Ñ…Ğ¾Ğ´";
Â  Â  Â  Â  Â  Â  document.getElementById('btn-create').disabled = false; document.getElementById('btn-create').innerText = "ğŸŒ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ ÑĞµÑ€Ğ²ĞµÑ€";
Â  Â  Â  Â  Â  Â  logNet("Ğ¡ĞµÑ‚ĞµĞ²Ğ¾Ğ¹ Ğ¼Ğ¾Ğ´ÑƒĞ»ÑŒ ÑĞ±Ñ€Ğ¾ÑˆĞµĞ½");
Â  Â  Â  Â  Â  Â  alert("Ğ¡ĞµÑ‚ÑŒ ÑĞ±Ñ€Ğ¾ÑˆĞµĞ½Ğ°. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ ÑĞµÑ€Ğ²ĞµÑ€ Ğ¸Ğ»Ğ¸ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒÑÑ ÑĞ½Ğ¾Ğ²Ğ°.");
Â  Â  Â  Â  }

Â  Â  Â  Â  // --- Ğ£Ğ»ÑƒÑ‡ÑˆĞµĞ½Ğ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ ÑĞµÑ€Ğ²ĞµÑ€Ğ° ---
Â  Â  Â  Â  function createGame(e) {Â 
Â  Â  Â  Â  Â  Â  e.stopPropagation();Â 
Â  Â  Â  Â  Â  Â  const btn = e.target; btn.disabled = true; btn.innerText = "Ğ—Ğ°Ğ¿ÑƒÑĞº...";
Â  Â  Â  Â  Â  Â  isHost = true;Â 
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  initPeer((id) => {
Â  Â  Â  Â  Â  Â  Â  Â  btn.disabled = false; btn.innerText = "ğŸŒ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ ÑĞµÑ€Ğ²ĞµÑ€";
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('setup-controls').style.display='none';Â 
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('lobby-controls').style.display='block';Â 
Â  Â  Â  Â  Â  Â  Â  Â  controls.getObject().position.set(0,15,0);
Â  Â  Â  Â  Â  Â  }, (err) => {
Â  Â  Â  Â  Â  Â  Â  Â  btn.disabled = false; btn.innerText = "ğŸŒ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ ÑĞµÑ€Ğ²ĞµÑ€";
Â  Â  Â  Â  Â  Â  Â  Â  alert("ĞÑˆĞ¸Ğ±ĞºĞ° Ğ·Ğ°Ğ¿ÑƒÑĞºĞ° ÑĞµÑ€Ğ²ĞµÑ€Ğ°: " + err);
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  function joinGame(e) {Â 
Â  Â  Â  Â  Â  Â  e.stopPropagation(); isHost = false;Â 
Â  Â  Â  Â  Â  Â  const id = document.getElementById('remote-id').value;Â 
Â  Â  Â  Â  Â  Â  if(!id) { alert("Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ID!"); return; }Â 

Â  Â  Â  Â  Â  Â  const btn = e.target; const originalText = btn.innerText;
Â  Â  Â  Â  Â  Â  btn.innerText = "ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ..."; btn.disabled = true;

Â  Â  Â  Â  Â  Â  initPeer((myId) => {
Â  Â  Â  Â  Â  Â  Â  Â  logNet("Connecting to: " + id);
Â  Â  Â  Â  Â  Â  Â  Â  conn = peer.connect(id, { reliable: true }); // Standard connection
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  const connTimeout = setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!isConnected) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  alert("Ğ¢Ğ°Ğ¹Ğ¼Ğ°ÑƒÑ‚ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ. Ğ•ÑĞ»Ğ¸ Ğ²Ñ‹ Ğ² Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾Ğ¹ ÑĞµÑ‚Ğ¸, Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ, Ñ‡Ñ‚Ğ¾ Ğ¾Ğ±Ğ° ÑƒÑÑ‚Ñ€Ğ¾Ğ¹ÑÑ‚Ğ²Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒÑÑ‚ HTTP (Ğ½Ğµ HTTPS).");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  btn.innerText = originalText; btn.disabled = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(conn) conn.close();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }, 15000);

Â  Â  Â  Â  Â  Â  Â  Â  handleConnection(conn, () => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  clearTimeout(connTimeout);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  btn.innerText = originalText; btn.disabled = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updateUI(false); controls.getObject().position.set(0,15,0); isGameActive=true;Â 
Â  Â  Â  Â  Â  Â  Â  Â  });Â 
Â  Â  Â  Â  Â  Â  }, (err) => {
Â  Â  Â  Â  Â  Â  Â  Â  btn.innerText = originalText; btn.disabled = false;
Â  Â  Â  Â  Â  Â  Â  Â  alert("ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ PeerJS: " + err);
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }

Â  Â  Â  Â  function prepareGame(e) { e.stopPropagation(); updateUI(false); isGameActive=true; }
Â  Â  Â  Â  function copyId() { navigator.clipboard.writeText(document.getElementById('my-id').value); showNotification("ID ÑĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½"); }
Â  Â  Â  Â Â 
Â  Â  Â  Â  function initPeer(onSuccess, onError) {
Â  Â  Â  Â  Â  Â  if (peer) peer.destroy();
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // AUTO-CONFIG: Use secure=true only if on HTTPS
Â  Â  Â  Â  Â  Â  // This is critical for local network (http://192.168.x.x)
Â  Â  Â  Â  Â  Â  const isSecure = location.protocol === 'https:';
Â  Â  Â  Â  Â  Â  logNet("Network Mode: " + (isSecure ? "Secure (HTTPS)" : "Insecure (HTTP/Local)"));

Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  peer = new Peer({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  secure: isSecure,Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  debug: 1,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  config: {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'iceServers': [
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  { urls: 'stun:stun.l.google.com:19302' },
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  { urls: 'stun:stun1.l.google.com:19302' },
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  { urls: 'stun:stun2.l.google.com:19302' }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ]
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  } catch(e) { if(onError) onError(e); return; }

Â  Â  Â  Â  Â  Â  let isOpen = false;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const initTimeout = setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  if(!isOpen) { if(onError) onError("Timeout connecting to PeerServer Cloud. Check Internet."); }
Â  Â  Â  Â  Â  Â  }, 10000);

Â  Â  Â  Â  Â  Â  peer.on('open', id => {
Â  Â  Â  Â  Â  Â  Â  Â  isOpen = true; clearTimeout(initTimeout);
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('my-id').value = id;
Â  Â  Â  Â  Â  Â  Â  Â  logNet("My ID: " + id);
Â  Â  Â  Â  Â  Â  Â  Â  if(onSuccess) onSuccess(id);
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  peer.on('connection', c => {Â 
Â  Â  Â  Â  Â  Â  Â  Â  conn = c;
Â  Â  Â  Â  Â  Â  Â  Â  logNet("Incoming connection...");
Â  Â  Â  Â  Â  Â  Â  Â  handleConnection(c);
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  peer.on('error', e => {
Â  Â  Â  Â  Â  Â  Â  Â  logNet("Peer Error: " + e.type);
Â  Â  Â  Â  Â  Â  Â  Â  if(!isOpen) { clearTimeout(initTimeout); if(onError) onError(e.type); }
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }

Â  Â  Â  Â  function handleConnection(connection, onSuccess = null) {
Â  Â  Â  Â  Â  Â  conn = connection;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // MONITORING ICE CANDIDATES
Â  Â  Â  Â  Â  Â  // We use the internal RTCPeerConnection to see what's happening
Â  Â  Â  Â  Â  Â  if(conn.peerConnection) {
Â  Â  Â  Â  Â  Â  Â  Â  conn.peerConnection.onicecandidate = (event) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (event.candidate) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const type = event.candidate.type || 'unknown'; // host, srflx, relay
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  logNet(`Found candidate: ${type} (${event.candidate.protocol})`);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  conn.peerConnection.oniceconnectionstatechange = () => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  logNet(`ICE State: ${conn.peerConnection.iceConnectionState}`);
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  conn.on('open', () => {
Â  Â  Â  Â  Â  Â  Â  Â  showNotification("Ğ¡Ğ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ¾!");
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('net-status').innerText = "ĞĞ½Ğ»Ğ°Ğ¹Ğ½";
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('net-status').classList.add('online');
Â  Â  Â  Â  Â  Â  Â  Â  logNet("Channel OPEN");
Â  Â  Â  Â  Â  Â  Â  Â  isConnected = true;
Â  Â  Â  Â  Â  Â  Â  Â  startNetworkLogic();
Â  Â  Â  Â  Â  Â  Â  Â  if (isHost) setTimeout(() => sendData({ type: 'ping' }), 100);
Â  Â  Â  Â  Â  Â  Â  Â  if (onSuccess) onSuccess();
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  conn.on('close', () => {Â 
Â  Â  Â  Â  Â  Â  Â  Â  showNotification("Ğ Ğ°Ğ·Ñ€Ñ‹Ğ² ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ");Â 
Â  Â  Â  Â  Â  Â  Â  Â  conn = null; isConnected = false;
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('net-status').innerText = "ĞÑ„Ğ»Ğ°Ğ¹Ğ½";
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('net-status').classList.remove('online');
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  conn.on('error', (err) => logNet("Conn Err: " + err));

Â  Â  Â  Â  Â  Â  conn.on('data', (data) => {
Â  Â  Â  Â  Â  Â  Â  Â  if (data.type === 'ping') return;
Â  Â  Â  Â  Â  Â  Â  Â  if (data.type === 'handshake_req') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  logNet("Handshake Requested.");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  showNotification("Ğ˜Ğ³Ñ€Ğ¾Ğº Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½Ğ¸Ğ»ÑÑ!");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  sendData({ type: 'handshake_ack', log: worldActionLog });
Â  Â  Â  Â  Â  Â  Â  Â  }Â 
Â  Â  Â  Â  Â  Â  Â  Â  else if (data.type === 'handshake_ack') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (handshakeInterval) { clearInterval(handshakeInterval); handshakeInterval = null; }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  logNet("World Sync: " + data.log.length);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  showNotification("Ğ¡Ğ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ!");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  data.log.forEach(action => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (action.type === 'add') addBlock(action.x, action.y, action.z, action.blockType, true);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  else if (action.type === 'remove') removeBlock(action.x, action.y, action.z, true);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  else if(data.type === 'move') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  otherPlayerTargetPos.set(data.pos.x, data.pos.y, data.pos.z);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  otherPlayerTargetRot = data.rot;
Â  Â  Â  Â  Â  Â  Â  Â  } else if (data.type === 'block_add') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  addBlock(data.x, data.y, data.z, data.blockType, true);
Â  Â  Â  Â  Â  Â  Â  Â  } else if (data.type === 'block_remove') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  removeBlock(data.x, data.y, data.z, true);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }

Â  Â  Â  Â  function startNetworkLogic() {
Â  Â  Â  Â  Â  Â  if (!isHost) {
Â  Â  Â  Â  Â  Â  Â  Â  logNet("Sending Handshake...");
Â  Â  Â  Â  Â  Â  Â  Â  sendData({ type: 'handshake_req' });
Â  Â  Â  Â  Â  Â  Â  Â  handshakeInterval = setInterval(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (conn && conn.open) { sendData({ type: 'handshake_req' }); }
Â  Â  Â  Â  Â  Â  Â  Â  }, 2000);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  setInterval(() => {
Â  Â  Â  Â  Â  Â  Â  Â  if (!conn || !conn.open) return;Â 
Â  Â  Â  Â  Â  Â  Â  Â  const p = camera;
Â  Â  Â  Â  Â  Â  Â  Â  const posToSend = {x: p.position.x, y: p.position.y - 1.8, z: p.position.z};Â 
Â  Â  Â  Â  Â  Â  Â  Â  const euler = new THREE.Euler(0, 0, 0, 'YXZ'); euler.setFromQuaternion(p.quaternion);
Â  Â  Â  Â  Â  Â  Â  Â  sendData({ type: 'move', pos: posToSend, rot: euler.y });
Â  Â  Â  Â  Â  Â  }, 1000 / 30);
Â  Â  Â  Â  }

Â  Â  Â  Â  window.addEventListener('resize', () => {
Â  Â  Â  Â  Â  Â  camera.aspect = window.innerWidth / window.innerHeight;
Â  Â  Â  Â  Â  Â  camera.updateProjectionMatrix();
Â  Â  Â  Â  Â  Â  renderer.setSize(window.innerWidth, window.innerHeight);
Â  Â  Â  Â  });
Â  Â  </script>
</body>
</html>
